"use strict";
/**
 * x402-stacks - Utility Functions
 * Helper functions for working with x402 payments on Stacks
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.microSTXtoSTX = microSTXtoSTX;
exports.STXtoMicroSTX = STXtoMicroSTX;
exports.satsToBTC = satsToBTC;
exports.BTCtoSats = BTCtoSats;
exports.USDCxToMicroUSDCx = USDCxToMicroUSDCx;
exports.microUSDCxToUSDCx = microUSDCxToUSDCx;
exports.generateKeypair = generateKeypair;
exports.isValidStacksAddress = isValidStacksAddress;
exports.getAddressNetwork = getAddressNetwork;
exports.getAPIEndpoint = getAPIEndpoint;
exports.getExplorerURL = getExplorerURL;
exports.formatPaymentAmount = formatPaymentAmount;
exports.parsePaymentMemo = parsePaymentMemo;
exports.createPaymentMemo = createPaymentMemo;
exports.estimateFee = estimateFee;
exports.waitWithBackoff = waitWithBackoff;
exports.retryWithBackoff = retryWithBackoff;
exports.isPaymentRequestExpired = isPaymentRequestExpired;
exports.createExpirationTimestamp = createExpirationTimestamp;
exports.truncateAddress = truncateAddress;
exports.getNetworkInstance = getNetworkInstance;
exports.getDefaultSBTCContract = getDefaultSBTCContract;
exports.getDefaultUSDCxContract = getDefaultUSDCxContract;
exports.getTokenSymbol = getTokenSymbol;
exports.getTokenDecimals = getTokenDecimals;
exports.getTokenSmallestUnit = getTokenSmallestUnit;
exports.networkToCAIP2 = networkToCAIP2;
exports.networkFromCAIP2 = networkFromCAIP2;
exports.isValidStacksCAIP2 = isValidStacksCAIP2;
exports.assetToV2 = assetToV2;
exports.assetFromV2 = assetFromV2;
const transactions_1 = require("@stacks/transactions");
const network_1 = require("@stacks/network");
const types_v2_1 = require("./types-v2");
/**
 * Convert microSTX to STX
 */
function microSTXtoSTX(microSTX) {
    const amount = typeof microSTX === 'string' ? BigInt(microSTX) : microSTX;
    return (Number(amount) / 1000000).toFixed(6);
}
/**
 * Convert STX to microSTX
 */
function STXtoMicroSTX(stx) {
    const amount = typeof stx === 'string' ? parseFloat(stx) : stx;
    return BigInt(Math.floor(amount * 1000000));
}
/**
 * Convert sats to BTC
 */
function satsToBTC(sats) {
    const amount = typeof sats === 'string' ? BigInt(sats) : sats;
    return (Number(amount) / 100000000).toFixed(8);
}
/**
 * Convert BTC to sats
 */
function BTCtoSats(btc) {
    const amount = typeof btc === 'string' ? parseFloat(btc) : btc;
    return BigInt(Math.floor(amount * 100000000));
}
/**
 * Convert USDCx to micro-units (6 decimals, same as USDC)
 */
function USDCxToMicroUSDCx(usdcx) {
    const amount = typeof usdcx === 'string' ? parseFloat(usdcx) : usdcx;
    return BigInt(Math.floor(amount * 1000000));
}
/**
 * Convert micro-USDCx to USDCx
 */
function microUSDCxToUSDCx(microUSDCx) {
    const amount = typeof microUSDCx === 'string' ? BigInt(microUSDCx) : microUSDCx;
    return (Number(amount) / 1000000).toFixed(6);
}
/**
 * Generate a random Stacks keypair
 */
function generateKeypair(network = 'testnet') {
    const privateKey = (0, transactions_1.makeRandomPrivKey)();
    const publicKey = (0, transactions_1.getPublicKey)(privateKey);
    const addressVersion = network === 'mainnet'
        ? transactions_1.AddressVersion.MainnetSingleSig
        : transactions_1.AddressVersion.TestnetSingleSig;
    const address = (0, transactions_1.publicKeyToAddress)(addressVersion, publicKey);
    return {
        privateKey: Buffer.from(privateKey.data).toString('hex'),
        publicKey: Buffer.from(publicKey.data).toString('hex'),
        address,
    };
}
/**
 * Validate Stacks address format
 */
function isValidStacksAddress(address) {
    // Stacks addresses start with SP (mainnet) or ST (testnet) followed by base58 characters
    const mainnetRegex = /^SP[0-9A-Z]{38,41}$/;
    const testnetRegex = /^ST[0-9A-Z]{38,41}$/;
    return mainnetRegex.test(address) || testnetRegex.test(address);
}
/**
 * Check if address is mainnet or testnet
 */
function getAddressNetwork(address) {
    if (!isValidStacksAddress(address)) {
        return null;
    }
    return address.startsWith('SP') ? 'mainnet' : 'testnet';
}
/**
 * Get API endpoint for network
 */
function getAPIEndpoint(network) {
    return network === 'mainnet'
        ? 'https://stacks-node-api.mainnet.stacks.co'
        : 'https://stacks-node-api.testnet.stacks.co';
}
/**
 * Get block explorer URL for transaction
 */
function getExplorerURL(txId, network = 'mainnet') {
    const chainParam = network === 'testnet' ? '?chain=testnet' : '';
    return `https://explorer.hiro.so/txid/0x${txId}${chainParam}`;
}
/**
 * Format payment amount for display
 */
function formatPaymentAmount(amount, options = {}) {
    const { includeSymbol = true, decimals = 6, tokenType = 'STX' } = options;
    let formattedAmount;
    let symbol;
    if (tokenType === 'sBTC') {
        const btc = satsToBTC(amount);
        formattedAmount = parseFloat(btc).toFixed(decimals);
        symbol = 'sBTC';
    }
    else if (tokenType === 'USDCx') {
        const usdcx = microUSDCxToUSDCx(amount);
        formattedAmount = parseFloat(usdcx).toFixed(decimals);
        symbol = 'USDCx';
    }
    else {
        const stx = microSTXtoSTX(amount);
        formattedAmount = parseFloat(stx).toFixed(decimals);
        symbol = 'STX';
    }
    return includeSymbol ? `${formattedAmount} ${symbol}` : formattedAmount;
}
/**
 * Parse memo field from x402 payment
 */
function parsePaymentMemo(memo) {
    const result = {};
    if (!memo.startsWith('x402:')) {
        return result;
    }
    // Remove x402: prefix
    const content = memo.substring(5);
    // Split by comma
    const parts = content.split(',');
    for (const part of parts) {
        const [key, value] = part.split('=');
        if (key && value) {
            if (key === 'resource') {
                result.resource = value;
            }
            else if (key === 'nonce') {
                result.nonce = value;
            }
            else {
                if (!result.custom) {
                    result.custom = {};
                }
                result.custom[key] = value;
            }
        }
    }
    return result;
}
/**
 * Create x402 memo string
 */
function createPaymentMemo(resource, nonce, custom) {
    let memo = `x402:${resource},nonce=${nonce}`;
    if (custom) {
        for (const [key, value] of Object.entries(custom)) {
            memo += `,${key}=${value}`;
        }
    }
    return memo;
}
/**
 * Calculate estimated fee for transaction
 */
function estimateFee(transactionSize = 180, feeRate = 1) {
    // Stacks fee calculation: size * rate
    return BigInt(transactionSize * feeRate);
}
/**
 * Wait with exponential backoff
 */
async function waitWithBackoff(attempt, baseDelayMs = 1000, maxDelayMs = 30000) {
    const delay = Math.min(baseDelayMs * Math.pow(2, attempt), maxDelayMs);
    return new Promise(resolve => setTimeout(resolve, delay));
}
/**
 * Retry function with exponential backoff
 */
async function retryWithBackoff(fn, maxAttempts = 3, baseDelayMs = 1000) {
    let lastError;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
            return await fn();
        }
        catch (error) {
            lastError = error instanceof Error ? error : new Error('Unknown error');
            if (attempt < maxAttempts - 1) {
                await waitWithBackoff(attempt, baseDelayMs);
            }
        }
    }
    throw lastError || new Error('Max retry attempts exceeded');
}
/**
 * Validate payment request expiration
 */
function isPaymentRequestExpired(expiresAt) {
    const expirationDate = new Date(expiresAt);
    return expirationDate < new Date();
}
/**
 * Create expiration timestamp
 */
function createExpirationTimestamp(secondsFromNow) {
    return new Date(Date.now() + secondsFromNow * 1000).toISOString();
}
/**
 * Truncate address for display
 */
function truncateAddress(address, chars = 6) {
    if (address.length <= chars * 2) {
        return address;
    }
    return `${address.slice(0, chars)}...${address.slice(-chars)}`;
}
/**
 * Get network instance from network type
 */
function getNetworkInstance(network) {
    return network === 'mainnet' ? new network_1.StacksMainnet() : new network_1.StacksTestnet();
}
/**
 * Get default sBTC contract for network
 */
function getDefaultSBTCContract(network) {
    if (network === 'mainnet') {
        // Mainnet sBTC contract
        return {
            address: 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4',
            name: 'sbtc-token',
        };
    }
    else {
        // Testnet sBTC contract
        return {
            address: 'ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT',
            name: 'sbtc-token',
        };
    }
}
/**
 * Get default USDCx contract for network
 * USDCx is Circle's USDC on Stacks via xReserve
 */
function getDefaultUSDCxContract(network) {
    if (network === 'mainnet') {
        // Mainnet USDCx contract
        return {
            address: 'SP120SBRBQJ00MCWS7TM5R8WJNTTKD5K0HFRC2CNE',
            name: 'usdcx',
        };
    }
    else {
        // Testnet USDCx contract
        return {
            address: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',
            name: 'usdcx',
        };
    }
}
/**
 * Get token symbol for display
 */
function getTokenSymbol(tokenType) {
    switch (tokenType) {
        case 'sBTC':
            return 'sBTC';
        case 'USDCx':
            return 'USDCx';
        default:
            return 'STX';
    }
}
/**
 * Get token decimals
 */
function getTokenDecimals(tokenType) {
    switch (tokenType) {
        case 'sBTC':
            return 8; // 1 sBTC = 100,000,000 sats
        case 'USDCx':
            return 6; // 1 USDCx = 1,000,000 micro-USDCx (same as USDC)
        default:
            return 6; // 1 STX = 1,000,000 microSTX
    }
}
/**
 * Get smallest unit name for token
 */
function getTokenSmallestUnit(tokenType) {
    switch (tokenType) {
        case 'sBTC':
            return 'sats';
        case 'USDCx':
            return 'micro-USDCx';
        default:
            return 'microSTX';
    }
}
// ===== V2 CAIP-2 Network Utilities =====
/**
 * Convert V1 network type to CAIP-2 format
 */
function networkToCAIP2(network) {
    return network === 'mainnet' ? types_v2_1.STACKS_NETWORKS.MAINNET : types_v2_1.STACKS_NETWORKS.TESTNET;
}
/**
 * Convert CAIP-2 network identifier to V1 network type
 * @throws Error if the CAIP-2 identifier is not a valid Stacks network
 */
function networkFromCAIP2(caip2) {
    switch (caip2) {
        case types_v2_1.STACKS_NETWORKS.MAINNET:
            return 'mainnet';
        case types_v2_1.STACKS_NETWORKS.TESTNET:
            return 'testnet';
        default:
            if (caip2.startsWith('stacks:')) {
                throw new Error(`Unsupported Stacks network: ${caip2}`);
            }
            throw new Error(`Invalid CAIP-2 format: ${caip2}`);
    }
}
/**
 * Check if a string is a valid Stacks CAIP-2 network identifier
 */
function isValidStacksCAIP2(caip2) {
    return caip2 === types_v2_1.STACKS_NETWORKS.MAINNET || caip2 === types_v2_1.STACKS_NETWORKS.TESTNET;
}
/**
 * Convert V1 token type to V2 asset identifier
 * For STX, returns "STX"
 * For SIP-010 tokens, returns the contract identifier (address.name)
 */
function assetToV2(tokenType, tokenContract) {
    switch (tokenType) {
        case 'STX':
            return 'STX';
        case 'sBTC':
            if (tokenContract) {
                return `${tokenContract.address}.${tokenContract.name}`;
            }
            return 'SBTC'; // Fallback symbol
        case 'USDCx':
            if (tokenContract) {
                return `${tokenContract.address}.${tokenContract.name}`;
            }
            return 'USDCX'; // Fallback symbol
        default:
            return 'STX';
    }
}
/**
 * Convert V2 asset identifier to V1 token type
 * Returns the token type and optionally the contract info
 */
function assetFromV2(asset) {
    // Check for native STX
    if (asset === 'STX') {
        return { tokenType: 'STX' };
    }
    // Check for known token symbols
    if (asset === 'SBTC') {
        return { tokenType: 'sBTC' };
    }
    if (asset === 'USDCX') {
        return { tokenType: 'USDCx' };
    }
    // Check if it's a contract identifier (address.name)
    if (asset.includes('.')) {
        const [address, name] = asset.split('.');
        // Try to identify known tokens by contract name
        if (name.toLowerCase().includes('sbtc') || name.toLowerCase() === 'sbtc-token') {
            return {
                tokenType: 'sBTC',
                tokenContract: { address, name },
            };
        }
        if (name.toLowerCase().includes('usdc') || name.toLowerCase() === 'usdcx') {
            return {
                tokenType: 'USDCx',
                tokenContract: { address, name },
            };
        }
        // Unknown SIP-010 token, default to STX behavior but include contract
        return {
            tokenType: 'STX', // Fallback
            tokenContract: { address, name },
        };
    }
    // Default to STX
    return { tokenType: 'STX' };
}
