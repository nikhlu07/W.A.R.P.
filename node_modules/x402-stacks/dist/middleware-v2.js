"use strict";
/**
 * x402-stacks - Express Middleware (Coinbase Compatible)
 * Middleware for handling x402 payment requirements in Express.js applications
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.paymentRateLimitV2 = exports.tieredPaymentV2 = exports.conditionalPaymentV2 = exports.createPaymentGateV2 = exports.getPaymentV2 = exports.x402PaymentRequiredV2 = void 0;
exports.paymentMiddleware = paymentMiddleware;
exports.getPayment = getPayment;
exports.createPaymentGate = createPaymentGate;
exports.conditionalPayment = conditionalPayment;
exports.tieredPayment = tieredPayment;
exports.paymentRateLimit = paymentRateLimit;
exports.parsePaymentRequiredHeader = parsePaymentRequiredHeader;
exports.parsePaymentResponseHeader = parsePaymentResponseHeader;
const verifier_v2_1 = require("./verifier-v2");
const types_v2_1 = require("./types-v2");
const utils_1 = require("./utils");
/**
 * Express middleware for x402 payment requirements
 * Compatible with Coinbase x402 protocol
 */
function paymentMiddleware(config) {
    const facilitatorUrl = config.facilitatorUrl || 'http://localhost:8085';
    const verifier = new verifier_v2_1.X402PaymentVerifier(facilitatorUrl);
    // Normalize network to CAIP-2 format
    const network = config.network.includes(':')
        ? config.network
        : (0, utils_1.networkToCAIP2)(config.network);
    // Normalize asset
    const asset = config.asset || (0, utils_1.assetToV2)(config.tokenType || 'STX', config.tokenContract);
    return async (req, res, next) => {
        try {
            // Check for payment in payment-signature header (V2 format, base64 encoded)
            const paymentSignatureHeader = req.headers[types_v2_1.X402_HEADERS.PAYMENT_SIGNATURE];
            // If no payment provided, return 402 Payment Required
            if (!paymentSignatureHeader) {
                return sendPaymentRequired(req, res, config, network, asset);
            }
            // Decode the payment payload from base64
            let paymentPayload;
            try {
                const decoded = Buffer.from(paymentSignatureHeader, 'base64').toString('utf-8');
                paymentPayload = JSON.parse(decoded);
            }
            catch (e) {
                return res.status(400).json({
                    error: types_v2_1.X402_ERROR_CODES.INVALID_PAYLOAD,
                    message: 'Invalid payment-signature header: failed to decode',
                });
            }
            // Validate x402 version
            if (paymentPayload.x402Version !== 2) {
                return res.status(400).json({
                    error: types_v2_1.X402_ERROR_CODES.INVALID_X402_VERSION,
                    message: 'Only x402 v2 is supported',
                });
            }
            // Build payment requirements
            const paymentRequirements = {
                scheme: config.scheme || 'exact',
                network,
                amount: config.amount.toString(),
                asset,
                payTo: config.payTo,
                maxTimeoutSeconds: config.maxTimeoutSeconds || 300,
                extra: config.extra,
            };
            // Settle the payment via facilitator
            const settlementResult = await verifier.settle(paymentPayload, { paymentRequirements });
            // Check if settlement was successful
            if (!settlementResult.success) {
                // Return 402 with error info
                const paymentRequired = createPaymentRequiredResponse(req, config, network, asset);
                // Encode payment required response for header
                const paymentRequiredHeader = Buffer.from(JSON.stringify(paymentRequired)).toString('base64');
                res.setHeader(types_v2_1.X402_HEADERS.PAYMENT_REQUIRED, paymentRequiredHeader);
                return res.status(402).json({
                    error: settlementResult.errorReason || types_v2_1.X402_ERROR_CODES.UNEXPECTED_SETTLE_ERROR,
                    payer: settlementResult.payer,
                    transaction: settlementResult.transaction,
                });
            }
            // Custom validator if provided
            if (config.paymentValidator) {
                const customValid = await config.paymentValidator(settlementResult);
                if (!customValid) {
                    return res.status(402).json({
                        error: 'custom_validation_failed',
                        message: 'Custom validation rejected the payment',
                    });
                }
            }
            // Payment is valid, attach payment info to request
            req.payment = settlementResult;
            req.paymentV2 = settlementResult;
            // Add payment-response header with settlement info (base64 encoded)
            const paymentResponse = {
                success: settlementResult.success,
                payer: settlementResult.payer,
                transaction: settlementResult.transaction,
                network: settlementResult.network,
            };
            res.setHeader(types_v2_1.X402_HEADERS.PAYMENT_RESPONSE, Buffer.from(JSON.stringify(paymentResponse)).toString('base64'));
            next();
        }
        catch (error) {
            console.error('x402 v2 middleware error:', error);
            return res.status(500).json({
                error: types_v2_1.X402_ERROR_CODES.UNEXPECTED_SETTLE_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    };
}
/**
 * Create payment required response object
 */
function createPaymentRequiredResponse(req, config, network, asset) {
    const resource = {
        url: `${req.protocol}://${req.get('host')}${req.originalUrl}`,
        description: config.description,
        mimeType: config.mimeType,
    };
    const paymentRequirements = {
        scheme: config.scheme || 'exact',
        network,
        amount: config.amount.toString(),
        asset,
        payTo: config.payTo,
        maxTimeoutSeconds: config.maxTimeoutSeconds || 300,
        extra: config.extra,
    };
    return {
        x402Version: 2,
        resource,
        accepts: [paymentRequirements],
    };
}
/**
 * Send 402 Payment Required response
 */
function sendPaymentRequired(req, res, config, network, asset) {
    const paymentRequired = createPaymentRequiredResponse(req, config, network, asset);
    // Set payment-required header (base64 encoded)
    const paymentRequiredHeader = Buffer.from(JSON.stringify(paymentRequired)).toString('base64');
    res.setHeader(types_v2_1.X402_HEADERS.PAYMENT_REQUIRED, paymentRequiredHeader);
    // Return JSON body as well for easier client consumption
    res.status(402).json(paymentRequired);
}
/**
 * Utility to get payment info from request
 */
function getPayment(req) {
    return req.payment || req.paymentV2;
}
/**
 * Create a simple payment gate that requires payment before proceeding
 */
function createPaymentGate(config) {
    return paymentMiddleware(config);
}
/**
 * Conditional payment middleware - only require payment if condition is met
 */
function conditionalPayment(condition, config) {
    const middleware = paymentMiddleware(config);
    return async (req, res, next) => {
        const shouldRequirePayment = await condition(req);
        if (shouldRequirePayment) {
            return middleware(req, res, next);
        }
        next();
    };
}
/**
 * Tiered payment middleware - different amounts based on request
 */
function tieredPayment(getTier, baseConfig) {
    return async (req, res, next) => {
        const tier = await getTier(req);
        const config = {
            ...baseConfig,
            amount: tier.amount,
            description: tier.description,
        };
        const middleware = paymentMiddleware(config);
        return middleware(req, res, next);
    };
}
/**
 * Rate limiting with payment - require payment after free tier
 */
function paymentRateLimit(config) {
    const requestCounts = new Map();
    const middleware = paymentMiddleware(config.paymentConfig);
    return async (req, res, next) => {
        const key = config.keyGenerator ? config.keyGenerator(req) : req.ip || 'unknown';
        const now = Date.now();
        let record = requestCounts.get(key);
        // Reset if window expired
        if (record && record.resetAt < now) {
            record = undefined;
        }
        // Initialize record if needed
        if (!record) {
            record = {
                count: 0,
                resetAt: now + config.windowMs,
            };
            requestCounts.set(key, record);
        }
        // Check if over free tier
        if (record.count >= config.freeRequests) {
            return middleware(req, res, next);
        }
        // Increment count and continue
        record.count++;
        next();
    };
}
/**
 * Parse payment-required header from a 402 response
 */
function parsePaymentRequiredHeader(header) {
    try {
        const decoded = Buffer.from(header, 'base64').toString('utf-8');
        return JSON.parse(decoded);
    }
    catch {
        return null;
    }
}
/**
 * Parse payment-response header from a successful response
 */
function parsePaymentResponseHeader(header) {
    try {
        const decoded = Buffer.from(header, 'base64').toString('utf-8');
        return JSON.parse(decoded);
    }
    catch {
        return null;
    }
}
/** @deprecated Use paymentMiddleware instead */
exports.x402PaymentRequiredV2 = paymentMiddleware;
/** @deprecated Use getPayment instead */
exports.getPaymentV2 = getPayment;
/** @deprecated Use createPaymentGate instead */
exports.createPaymentGateV2 = createPaymentGate;
/** @deprecated Use conditionalPayment instead */
exports.conditionalPaymentV2 = conditionalPayment;
/** @deprecated Use tieredPayment instead */
exports.tieredPaymentV2 = tieredPayment;
/** @deprecated Use paymentRateLimit instead */
exports.paymentRateLimitV2 = paymentRateLimit;
