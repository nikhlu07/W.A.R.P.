"use strict";
/**
 * x402-stacks - Express Middleware (V1 Legacy)
 * Middleware for handling x402 V1 payment requirements in Express.js applications
 * Note: For new projects, use paymentMiddleware from middleware-v2.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.paymentRateLimit = exports.tieredPayment = exports.conditionalPayment = exports.createPaymentGate = exports.getPayment = exports.x402PaymentRequired = void 0;
exports.paymentMiddlewareV1 = paymentMiddlewareV1;
exports.getPaymentV1 = getPaymentV1;
exports.createPaymentGateV1 = createPaymentGateV1;
exports.conditionalPaymentV1 = conditionalPaymentV1;
exports.tieredPaymentV1 = tieredPaymentV1;
exports.paymentRateLimitV1 = paymentRateLimitV1;
const verifier_1 = require("./verifier");
const crypto_1 = require("crypto");
/**
 * Express middleware for x402 V1 payment requirements
 * @deprecated Use paymentMiddleware from the main exports instead
 */
function paymentMiddlewareV1(config) {
    const facilitatorUrl = config.facilitatorUrl || 'http://localhost:8085';
    const verifier = new verifier_1.X402PaymentVerifierV1(facilitatorUrl, config.network);
    return async (req, res, next) => {
        try {
            // Check for signed payment in X-PAYMENT header (x402 facilitator pattern)
            // Also support legacy x-payment-txid for backwards compatibility
            const signedPayment = req.headers['x-payment'];
            const legacyTxId = req.headers['x-payment-txid'] ||
                req.query.paymentTxId ||
                req.body?.paymentTxId;
            // If no payment provided, return 402 Payment Required
            if (!signedPayment && !legacyTxId) {
                return sendPaymentRequired(req, res, config);
            }
            // Determine token type from header or config
            const headerTokenType = req.headers['x-payment-token-type']?.toLowerCase();
            let tokenType = config.tokenType || 'STX';
            if (headerTokenType === 'sbtc') {
                tokenType = 'sBTC';
            }
            else if (headerTokenType === 'usdcx') {
                tokenType = 'USDCx';
            }
            let verification;
            if (signedPayment) {
                // New x402 facilitator pattern: settle the signed transaction
                const settleOptions = {
                    expectedRecipient: config.address,
                    minAmount: BigInt(config.amount),
                    tokenType,
                    resource: config.resource || req.path,
                    method: req.method,
                };
                verification = await verifier.settlePayment(signedPayment, settleOptions);
            }
            else {
                // Legacy flow: verify existing transaction by ID
                verification = await verifier.verifyPayment(legacyTxId, {
                    expectedRecipient: config.address,
                    minAmount: BigInt(config.amount),
                    resource: config.resource || req.path,
                    method: req.method,
                    tokenType: config.tokenType,
                    tokenContract: config.tokenContract,
                });
            }
            // Check if payment is valid
            if (!verification.isValid) {
                return res.status(402).json({
                    error: 'Invalid payment',
                    details: verification.validationError,
                    paymentStatus: verification.status,
                });
            }
            // Check payment status - must be confirmed
            if (verification.status === 'pending') {
                return res.status(402).json({
                    error: 'Payment not yet confirmed',
                    details: 'Please wait for transaction confirmation on the blockchain',
                    paymentStatus: 'pending',
                });
            }
            if (verification.status === 'failed') {
                return res.status(402).json({
                    error: 'Payment failed',
                    details: 'Transaction failed on blockchain',
                    paymentStatus: 'failed',
                });
            }
            // Custom validator if provided
            if (config.paymentValidator) {
                const customValid = await config.paymentValidator(verification);
                if (!customValid) {
                    return res.status(402).json({
                        error: 'Payment validation failed',
                        details: 'Custom validation rejected the payment',
                    });
                }
            }
            // Payment is valid, attach payment info to request and continue
            req.payment = verification;
            // Add X-PAYMENT-RESPONSE header with settlement info (per x402 spec)
            const paymentResponse = {
                txId: verification.txId,
                status: verification.status,
                blockHeight: verification.blockHeight,
            };
            res.setHeader('X-PAYMENT-RESPONSE', Buffer.from(JSON.stringify(paymentResponse)).toString('base64'));
            next();
        }
        catch (error) {
            console.error('x402 middleware error:', error);
            return res.status(500).json({
                error: 'Payment settlement error',
                details: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    };
}
/**
 * Send 402 Payment Required response
 */
function sendPaymentRequired(req, res, config) {
    const expirationSeconds = config.expirationSeconds || 300; // 5 minutes default
    const expiresAt = new Date(Date.now() + expirationSeconds * 1000).toISOString();
    const nonce = config.nonceGenerator
        ? config.nonceGenerator()
        : (0, crypto_1.randomBytes)(16).toString('hex');
    const resource = config.resource || req.path;
    const paymentRequest = {
        maxAmountRequired: config.amount.toString(),
        resource,
        payTo: config.address,
        network: config.network,
        nonce,
        expiresAt,
        tokenType: config.tokenType,
        tokenContract: config.tokenContract,
    };
    res.status(402).json(paymentRequest);
}
/**
 * Utility to get V1 payment info from request
 * @deprecated Use getPayment from the main exports instead
 */
function getPaymentV1(req) {
    return req.payment;
}
/**
 * Create a simple payment gate that requires payment (V1)
 * @deprecated Use createPaymentGate from the main exports instead
 */
function createPaymentGateV1(config) {
    return paymentMiddlewareV1(config);
}
/**
 * Conditional payment middleware (V1)
 * @deprecated Use conditionalPayment from the main exports instead
 */
function conditionalPaymentV1(condition, config) {
    const middleware = paymentMiddlewareV1(config);
    return async (req, res, next) => {
        const shouldRequirePayment = await condition(req);
        if (shouldRequirePayment) {
            return middleware(req, res, next);
        }
        next();
    };
}
/**
 * Tiered payment middleware (V1)
 * @deprecated Use tieredPayment from the main exports instead
 */
function tieredPaymentV1(getTier, baseConfig) {
    return async (req, res, next) => {
        const tier = await getTier(req);
        const config = {
            ...baseConfig,
            amount: tier.amount,
            resource: tier.resource,
        };
        const middleware = paymentMiddlewareV1(config);
        return middleware(req, res, next);
    };
}
/**
 * Rate limiting with payment (V1)
 * @deprecated Use paymentRateLimit from the main exports instead
 */
function paymentRateLimitV1(config) {
    const requestCounts = new Map();
    const middleware = paymentMiddlewareV1(config.paymentConfig);
    return async (req, res, next) => {
        const key = config.keyGenerator ? config.keyGenerator(req) : req.ip || 'unknown';
        const now = Date.now();
        let record = requestCounts.get(key);
        // Reset if window expired
        if (record && record.resetAt < now) {
            record = undefined;
        }
        // Initialize record if needed
        if (!record) {
            record = {
                count: 0,
                resetAt: now + config.windowMs,
            };
            requestCounts.set(key, record);
        }
        // Check if over free tier
        if (record.count >= config.freeRequests) {
            return middleware(req, res, next);
        }
        // Increment count and continue
        record.count++;
        next();
    };
}
// ===== Backward Compatibility Aliases =====
/** @deprecated Use paymentMiddleware from the main exports */
exports.x402PaymentRequired = paymentMiddlewareV1;
/** @deprecated Use getPayment from the main exports */
exports.getPayment = getPaymentV1;
/** @deprecated Use createPaymentGate from the main exports */
exports.createPaymentGate = createPaymentGateV1;
/** @deprecated Use conditionalPayment from the main exports */
exports.conditionalPayment = conditionalPaymentV1;
/** @deprecated Use tieredPayment from the main exports */
exports.tieredPayment = tieredPaymentV1;
/** @deprecated Use paymentRateLimit from the main exports */
exports.paymentRateLimit = paymentRateLimitV1;
