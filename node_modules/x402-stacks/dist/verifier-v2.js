"use strict";
/**
 * x402-stacks - Payment Verifier (Coinbase Compatible)
 * Handles verification and settlement of payments using x402 protocol
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVerifierV2 = exports.X402PaymentVerifierV2 = exports.X402PaymentVerifier = void 0;
exports.createVerifier = createVerifier;
const axios_1 = __importDefault(require("axios"));
const types_v2_1 = require("./types-v2");
/**
 * Payment verifier for validating x402 payments on Stacks
 * Compatible with Coinbase x402 protocol
 */
class X402PaymentVerifier {
    constructor(facilitatorUrl = 'http://localhost:8085') {
        this.facilitatorUrl = facilitatorUrl.replace(/\/$/, ''); // Remove trailing slash
        this.httpClient = axios_1.default.create({
            timeout: 30000, // V2 may need longer timeout for settlement
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    /**
     * Verify a payment using the V2 facilitator API
     * This verifies the signed transaction without broadcasting it
     */
    async verify(paymentPayload, options) {
        try {
            const request = {
                x402Version: 2,
                paymentPayload,
                paymentRequirements: options.paymentRequirements,
            };
            const response = await this.httpClient.post(`${this.facilitatorUrl}/verify`, request);
            return response.data;
        }
        catch (error) {
            // Handle API errors
            if (axios_1.default.isAxiosError(error) && error.response?.data) {
                const errorData = error.response.data;
                return {
                    isValid: false,
                    invalidReason: errorData.invalidReason || types_v2_1.X402_ERROR_CODES.UNEXPECTED_VERIFY_ERROR,
                    payer: errorData.payer,
                };
            }
            return {
                isValid: false,
                invalidReason: types_v2_1.X402_ERROR_CODES.UNEXPECTED_VERIFY_ERROR,
            };
        }
    }
    /**
     * Settle a payment using the V2 facilitator API
     * This broadcasts the transaction and waits for confirmation
     */
    async settle(paymentPayload, options) {
        try {
            const request = {
                x402Version: 2,
                paymentPayload,
                paymentRequirements: options.paymentRequirements,
            };
            const response = await this.httpClient.post(`${this.facilitatorUrl}/settle`, request);
            return response.data;
        }
        catch (error) {
            // Handle API errors
            if (axios_1.default.isAxiosError(error) && error.response?.data) {
                const errorData = error.response.data;
                return {
                    success: false,
                    errorReason: errorData.errorReason || types_v2_1.X402_ERROR_CODES.UNEXPECTED_SETTLE_ERROR,
                    payer: errorData.payer,
                    transaction: errorData.transaction || '',
                    network: errorData.network || options.paymentRequirements.network,
                };
            }
            return {
                success: false,
                errorReason: types_v2_1.X402_ERROR_CODES.UNEXPECTED_SETTLE_ERROR,
                transaction: '',
                network: options.paymentRequirements.network,
            };
        }
    }
    /**
     * Get supported payment kinds from the facilitator
     */
    async getSupported() {
        try {
            const response = await this.httpClient.get(`${this.facilitatorUrl}/supported`);
            return response.data;
        }
        catch (error) {
            // Return empty supported response on error
            return {
                kinds: [],
                extensions: [],
                signers: {},
            };
        }
    }
    /**
     * Check if a specific payment kind is supported
     */
    async isKindSupported(network, scheme = 'exact', x402Version = 2) {
        const supported = await this.getSupported();
        return supported.kinds.some((kind) => kind.x402Version === x402Version &&
            kind.scheme === scheme &&
            kind.network === network);
    }
    /**
     * Verify and settle in one operation
     * First verifies the payment, then settles if valid
     */
    async verifyAndSettle(paymentPayload, options) {
        // First verify
        const verifyResult = await this.verify(paymentPayload, options);
        if (!verifyResult.isValid) {
            return {
                success: false,
                errorReason: verifyResult.invalidReason || types_v2_1.X402_ERROR_CODES.UNEXPECTED_VERIFY_ERROR,
                payer: verifyResult.payer,
                transaction: '',
                network: options.paymentRequirements.network,
            };
        }
        // Then settle
        return this.settle(paymentPayload, options);
    }
    /**
     * Create a payment payload from a signed transaction
     * Helper for constructing V2 payment payloads
     */
    static createPaymentPayload(signedTransaction, paymentRequirements) {
        return {
            x402Version: 2,
            accepted: paymentRequirements,
            payload: {
                transaction: signedTransaction,
            },
        };
    }
    /**
     * Quick check if a payment is valid (returns boolean only)
     */
    async isPaymentValid(paymentPayload, options) {
        const result = await this.verify(paymentPayload, options);
        return result.isValid;
    }
}
exports.X402PaymentVerifier = X402PaymentVerifier;
/**
 * Create a verifier instance
 */
function createVerifier(facilitatorUrl) {
    return new X402PaymentVerifier(facilitatorUrl);
}
// ===== Backward Compatibility Aliases =====
/** @deprecated Use X402PaymentVerifier instead */
exports.X402PaymentVerifierV2 = X402PaymentVerifier;
/** @deprecated Use createVerifier instead */
exports.createVerifierV2 = createVerifier;
