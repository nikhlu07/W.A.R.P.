"use strict";
/**
 * x402-stacks - Axios Payment Interceptor (V1 Legacy)
 * Provides automatic x402 V1 payment handling for axios instances
 * Note: For new projects, use the default exports from interceptor-v2.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPaymentClient = exports.withPaymentInterceptor = exports.privateKeyToAccount = void 0;
exports.privateKeyToAccountV1 = privateKeyToAccountV1;
exports.decodeXPaymentResponse = decodeXPaymentResponse;
exports.encodeXPaymentResponse = encodeXPaymentResponse;
exports.wrapAxiosWithPaymentV1 = wrapAxiosWithPaymentV1;
exports.createPaymentClientV1 = createPaymentClientV1;
const transactions_1 = require("@stacks/transactions");
const network_1 = require("@stacks/network");
/**
 * Create a Stacks account from a private key (V1)
 * @deprecated Use privateKeyToAccount from the main exports instead
 */
function privateKeyToAccountV1(privateKey, network = 'testnet') {
    const transactionVersion = network === 'mainnet'
        ? transactions_1.TransactionVersion.Mainnet
        : transactions_1.TransactionVersion.Testnet;
    const address = (0, transactions_1.getAddressFromPrivateKey)(privateKey, transactionVersion);
    return {
        address,
        privateKey,
        network,
    };
}
/**
 * Decode the X-PAYMENT-RESPONSE header from base64 JSON
 */
function decodeXPaymentResponse(header) {
    if (!header)
        return null;
    try {
        const decoded = Buffer.from(header, 'base64').toString('utf-8');
        return JSON.parse(decoded);
    }
    catch {
        return null;
    }
}
/**
 * Encode a payment response to base64 JSON (for servers)
 */
function encodeXPaymentResponse(response) {
    return Buffer.from(JSON.stringify(response)).toString('base64');
}
/**
 * Get Stacks network instance from network type
 */
function getNetworkInstance(network) {
    return network === 'mainnet' ? new network_1.StacksMainnet() : new network_1.StacksTestnet();
}
/**
 * Sign a payment transaction based on x402 payment request
 * Returns the signed transaction hex (does not broadcast)
 */
async function signPayment(paymentRequest, account) {
    const amount = BigInt(paymentRequest.maxAmountRequired);
    const tokenType = paymentRequest.tokenType || 'STX';
    const network = getNetworkInstance(paymentRequest.network);
    const memo = paymentRequest.nonce.substring(0, 34); // Max 34 bytes for Stacks memo
    if (tokenType === 'sBTC' || tokenType === 'USDCx') {
        // sBTC or USDCx transfer (SIP-010 contract call)
        if (!paymentRequest.tokenContract) {
            throw new Error(`Token contract required for ${tokenType} payments`);
        }
        const { address: contractAddress, name: contractName } = paymentRequest.tokenContract;
        const functionArgs = [
            (0, transactions_1.uintCV)(amount.toString()),
            (0, transactions_1.principalCV)(account.address),
            (0, transactions_1.principalCV)(paymentRequest.payTo),
            memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(memo)) : (0, transactions_1.noneCV)(),
        ];
        const transaction = await (0, transactions_1.makeContractCall)({
            contractAddress,
            contractName,
            functionName: 'transfer',
            functionArgs,
            senderKey: account.privateKey,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
            postConditionMode: transactions_1.PostConditionMode.Allow,
        });
        // Convert Uint8Array to hex string
        const serialized = transaction.serialize();
        return Buffer.from(serialized).toString('hex');
    }
    else {
        // STX transfer
        const transaction = await (0, transactions_1.makeSTXTokenTransfer)({
            recipient: paymentRequest.payTo,
            amount,
            senderKey: account.privateKey,
            network,
            memo,
            anchorMode: transactions_1.AnchorMode.Any,
        });
        // Convert Uint8Array to hex string
        const serialized = transaction.serialize();
        return Buffer.from(serialized).toString('hex');
    }
}
/**
 * Validate that a response body is a valid x402 payment request
 */
function isValidPaymentRequest(data) {
    if (!data || typeof data !== 'object')
        return false;
    const request = data;
    return (typeof request.maxAmountRequired === 'string' &&
        typeof request.resource === 'string' &&
        typeof request.payTo === 'string' &&
        typeof request.network === 'string' &&
        typeof request.nonce === 'string' &&
        typeof request.expiresAt === 'string' &&
        (request.network === 'mainnet' || request.network === 'testnet'));
}
// Track which requests have already had payment attempted
const paymentAttempted = new WeakSet();
/**
 * Wrap an axios instance with automatic x402 V1 payment handling
 * @deprecated Use wrapAxiosWithPayment from the main exports instead
 *
 * @example
 * ```typescript
 * import axios from 'axios';
 * import { wrapAxiosWithPaymentV1, privateKeyToAccountV1 } from 'x402-stacks';
 *
 * const account = privateKeyToAccountV1(process.env.PRIVATE_KEY!, 'testnet');
 *
 * const api = wrapAxiosWithPaymentV1(
 *   axios.create({ baseURL: 'https://api.example.com' }),
 *   account
 * );
 *
 * // Use normally - 402 handling is automatic
 * const response = await api.get('/premium-data');
 * console.log(response.data);
 * ```
 */
function wrapAxiosWithPaymentV1(axiosInstance, account) {
    // Response interceptor to handle 402 Payment Required
    axiosInstance.interceptors.response.use(
    // Pass through successful responses
    (response) => response, 
    // Handle errors (including 402)
    async (error) => {
        const originalRequest = error.config;
        // Check if this is a 402 response
        if (error.response?.status !== 402) {
            return Promise.reject(error);
        }
        // Prevent infinite retry loops - only attempt payment once per request
        if (paymentAttempted.has(originalRequest)) {
            return Promise.reject(new Error('Payment already attempted for this request'));
        }
        // Mark this request as having payment attempted
        paymentAttempted.add(originalRequest);
        const paymentRequest = error.response.data;
        // Validate payment request structure
        if (!isValidPaymentRequest(paymentRequest)) {
            return Promise.reject(new Error('Invalid x402 payment request from server'));
        }
        // Check expiration
        const expiresAt = new Date(paymentRequest.expiresAt);
        if (expiresAt < new Date()) {
            return Promise.reject(new Error('Payment request has expired'));
        }
        try {
            // Sign the payment (don't broadcast - server will do that)
            const signedTransaction = await signPayment(paymentRequest, account);
            // Retry the request with the signed payment
            originalRequest.headers = originalRequest.headers || {};
            originalRequest.headers['X-PAYMENT'] = signedTransaction;
            originalRequest.headers['X-PAYMENT-TOKEN-TYPE'] = paymentRequest.tokenType || 'STX';
            // Make the retry request
            return axiosInstance.request(originalRequest);
        }
        catch (paymentError) {
            return Promise.reject(new Error(`Payment signing failed: ${paymentError instanceof Error ? paymentError.message : 'Unknown error'}`));
        }
    });
    return axiosInstance;
}
/**
 * Create a pre-configured axios instance with V1 payment handling
 * @deprecated Use createPaymentClient from the main exports instead
 *
 * @example
 * ```typescript
 * import { createPaymentClientV1, privateKeyToAccountV1 } from 'x402-stacks';
 *
 * const account = privateKeyToAccountV1(process.env.PRIVATE_KEY!, 'testnet');
 * const api = createPaymentClientV1(account, { baseURL: 'https://api.example.com' });
 *
 * const response = await api.get('/premium-data');
 * ```
 */
function createPaymentClientV1(account, config) {
    // Dynamic import to avoid requiring axios at module load time
    const axios = require('axios');
    const instance = axios.create(config);
    return wrapAxiosWithPaymentV1(instance, account);
}
// ===== Backward Compatibility Aliases =====
/** @deprecated Use privateKeyToAccount from the main exports */
exports.privateKeyToAccount = privateKeyToAccountV1;
/** @deprecated Use wrapAxiosWithPayment from the main exports */
exports.withPaymentInterceptor = wrapAxiosWithPaymentV1;
/** @deprecated Use createPaymentClient from the main exports */
exports.createPaymentClient = createPaymentClientV1;
