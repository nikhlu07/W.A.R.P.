"use strict";
/**
 * x402-stacks - Payment Verifier (V1 Legacy)
 * Handles verification of STX token transfers using V1 facilitator API
 * Note: For new projects, use X402PaymentVerifier from verifier-v2.ts
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.X402PaymentVerifier = exports.X402PaymentVerifierV1 = void 0;
const axios_1 = __importDefault(require("axios"));
/**
 * Payment verifier for validating x402 V1 payments on Stacks
 * @deprecated Use X402PaymentVerifier from the main exports instead
 */
class X402PaymentVerifierV1 {
    constructor(facilitatorUrl = 'http://localhost:8085', network = 'mainnet') {
        this.facilitatorUrl = facilitatorUrl;
        this.network = network;
        this.httpClient = axios_1.default.create({
            timeout: 15000,
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    /**
     * Verify a payment transaction using facilitator API
     * Always requires confirmed transactions
     */
    async verifyPayment(txId, options) {
        try {
            // Build facilitator API request (always require confirmed transactions)
            const request = {
                tx_id: txId,
                expected_recipient: options.expectedRecipient,
                min_amount: Number(options.minAmount),
                expected_sender: options.expectedSender,
                expected_memo: options.expectedMemo,
                network: this.network,
                resource: options.resource,
                method: options.method,
                // Map token type to facilitator API format (STX, SBTC, or USDCX)
                token_type: options.tokenType === 'sBTC' ? 'SBTC' : options.tokenType === 'USDCx' ? 'USDCX' : 'STX',
            };
            // Call facilitator API
            const response = await this.httpClient.post(`${this.facilitatorUrl}/api/v1/verify`, request);
            const data = response.data;
            // Map facilitator response to VerifiedPayment
            return this.mapFacilitatorResponse(txId, data);
        }
        catch (error) {
            // Handle API errors
            if (error.response?.data) {
                const errorData = error.response.data;
                // If facilitator returned validation errors
                if (errorData.valid === false) {
                    return {
                        txId,
                        status: 'not_found',
                        sender: errorData.sender_address || '',
                        recipient: errorData.recipient_address || '',
                        amount: BigInt(errorData.amount || 0),
                        memo: errorData.memo,
                        blockHeight: errorData.block_height,
                        isValid: false,
                        validationError: errorData.validation_errors?.join(', ') || 'Payment validation failed',
                    };
                }
                // If facilitator returned an error
                if (errorData.error) {
                    return {
                        txId,
                        status: 'not_found',
                        sender: '',
                        recipient: '',
                        amount: BigInt(0),
                        isValid: false,
                        validationError: errorData.error,
                    };
                }
            }
            return {
                txId,
                status: 'not_found',
                sender: '',
                recipient: '',
                amount: BigInt(0),
                isValid: false,
                validationError: error instanceof Error ? error.message : 'Verification failed',
            };
        }
    }
    /**
     * Map facilitator API response to VerifiedPayment
     */
    mapFacilitatorResponse(txId, data) {
        // Map facilitator status to PaymentStatus
        let status = 'not_found';
        if (data.status === 'confirmed') {
            status = 'success';
        }
        else if (data.status === 'pending') {
            status = 'pending';
        }
        else if (data.status === 'failed') {
            status = 'failed';
        }
        return {
            txId: data.tx_id || txId,
            status,
            sender: data.sender_address || '',
            recipient: data.recipient_address || '',
            amount: BigInt(data.amount || 0),
            memo: data.memo,
            blockHeight: data.block_height,
            timestamp: undefined, // Facilitator doesn't return timestamp
            isValid: data.valid,
            validationError: data.validation_errors?.join(', '),
        };
    }
    /**
     * Quick check if a payment is valid (returns boolean only)
     */
    async isPaymentValid(txId, options) {
        const verification = await this.verifyPayment(txId, options);
        return verification.isValid && verification.status === 'success';
    }
    /**
     * Settle a payment using the V1 facilitator API
     */
    async settlePayment(signedTransaction, options) {
        try {
            // Build facilitator API request
            const request = {
                signed_transaction: signedTransaction,
                expected_recipient: options.expectedRecipient,
                min_amount: Number(options.minAmount),
                expected_sender: options.expectedSender,
                network: this.network,
                resource: options.resource,
                method: options.method,
                token_type: options.tokenType === 'sBTC' ? 'SBTC' : options.tokenType === 'USDCx' ? 'USDCX' : 'STX',
            };
            // Call facilitator API settle endpoint
            const response = await this.httpClient.post(`${this.facilitatorUrl}/api/v1/settle`, request);
            const data = response.data;
            // Map facilitator response to VerifiedPayment
            return this.mapSettleResponse(data);
        }
        catch (error) {
            // Handle API errors
            if (error.response?.data) {
                const errorData = error.response.data;
                // If facilitator returned validation errors
                if (errorData.success === false) {
                    return {
                        txId: errorData.tx_id || '',
                        status: 'failed',
                        sender: errorData.sender_address || '',
                        recipient: errorData.recipient_address || '',
                        amount: BigInt(errorData.amount || 0),
                        blockHeight: errorData.block_height,
                        isValid: false,
                        validationError: errorData.validation_errors?.join(', ') || errorData.error || 'Settlement failed',
                    };
                }
            }
            return {
                txId: '',
                status: 'failed',
                sender: '',
                recipient: '',
                amount: BigInt(0),
                isValid: false,
                validationError: error instanceof Error ? error.message : 'Settlement failed',
            };
        }
    }
    /**
     * Map facilitator settle response to VerifiedPayment
     */
    mapSettleResponse(data) {
        // Map facilitator status to PaymentStatus
        let status = 'failed';
        if (data.success && data.status === 'confirmed') {
            status = 'success';
        }
        else if (data.status === 'pending') {
            status = 'pending';
        }
        return {
            txId: data.tx_id || '',
            status,
            sender: data.sender_address || '',
            recipient: data.recipient_address || '',
            amount: BigInt(data.amount || 0),
            blockHeight: data.block_height,
            timestamp: undefined,
            isValid: data.success === true && data.status === 'confirmed',
            validationError: data.validation_errors?.join(', ') || data.error,
        };
    }
    /**
     * Wait for transaction confirmation with polling
     * Polls until transaction is confirmed on blockchain
     */
    async waitForConfirmation(txId, options, maxAttempts = 20, intervalMs = 30000) {
        for (let i = 0; i < maxAttempts; i++) {
            const verification = await this.verifyPayment(txId, options);
            if (verification.isValid && verification.status === 'success') {
                return verification;
            }
            if (verification.status === 'failed') {
                throw new Error(`Transaction failed: ${verification.validationError}`);
            }
            // Wait before next attempt
            await new Promise((resolve) => setTimeout(resolve, intervalMs));
        }
        return null;
    }
}
exports.X402PaymentVerifierV1 = X402PaymentVerifierV1;
// ===== Backward Compatibility Aliases =====
/** @deprecated Use X402PaymentVerifier from the main exports */
exports.X402PaymentVerifier = X402PaymentVerifierV1;
