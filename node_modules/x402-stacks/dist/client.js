"use strict";
/**
 * x402-stacks - Payment Client
 * Handles constructing and broadcasting STX token transfers
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.X402PaymentClient = void 0;
const transactions_1 = require("@stacks/transactions");
const network_1 = require("@stacks/network");
const axios_1 = __importDefault(require("axios"));
/**
 * Payment client for making x402 payments on Stacks
 */
class X402PaymentClient {
    constructor(config) {
        this.network = this.getNetworkInstance(config.network);
        this.privateKey = config.privateKey;
        this.httpClient = axios_1.default.create({
            timeout: config.timeout || 30000,
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    /**
     * Get Stacks network instance from network type
     */
    getNetworkInstance(network) {
        return network === 'mainnet' ? new network_1.StacksMainnet() : new network_1.StacksTestnet();
    }
    /**
     * Sign a payment based on x402 payment request (without broadcasting)
     * Returns the signed transaction hex to be sent to the facilitator
     */
    async signPayment(paymentRequest) {
        try {
            const amount = BigInt(paymentRequest.maxAmountRequired);
            const tokenType = paymentRequest.tokenType || 'STX';
            const paymentDetails = {
                recipient: paymentRequest.payTo,
                amount,
                senderKey: this.privateKey,
                network: paymentRequest.network,
                memo: paymentRequest.nonce.substring(0, 34), // Max 34 bytes for Stacks memo
                tokenType,
                tokenContract: paymentRequest.tokenContract,
            };
            if (tokenType === 'sBTC') {
                return await this.signSBTCTransfer(paymentDetails);
            }
            else if (tokenType === 'USDCx') {
                return await this.signUSDCxTransfer(paymentDetails);
            }
            else {
                return await this.signSTXTransfer(paymentDetails);
            }
        }
        catch (error) {
            return {
                signedTransaction: '',
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Make a payment based on x402 payment request (broadcasts directly)
     * @deprecated Use signPayment() with facilitator settle endpoint instead
     */
    async makePayment(paymentRequest) {
        try {
            const amount = BigInt(paymentRequest.maxAmountRequired);
            const tokenType = paymentRequest.tokenType || 'STX';
            const paymentDetails = {
                recipient: paymentRequest.payTo,
                amount,
                senderKey: this.privateKey,
                network: paymentRequest.network,
                memo: paymentRequest.nonce.substring(0, 34), // Max 34 bytes for Stacks memo
                tokenType,
                tokenContract: paymentRequest.tokenContract,
            };
            if (tokenType === 'sBTC') {
                return await this.sendSBTCTransfer(paymentDetails);
            }
            else if (tokenType === 'USDCx') {
                return await this.sendUSDCxTransfer(paymentDetails);
            }
            else {
                return await this.sendSTXTransfer(paymentDetails);
            }
        }
        catch (error) {
            return {
                txId: '',
                txRaw: '',
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Sign STX token transfer (without broadcasting)
     */
    async signSTXTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Get sender address from private key
            const senderAddress = (0, transactions_1.getAddressFromPrivateKey)(details.senderKey, network instanceof network_1.StacksMainnet ? transactions_1.TransactionVersion.Mainnet : transactions_1.TransactionVersion.Testnet);
            // Build transaction options
            const txOptions = {
                recipient: details.recipient,
                amount: details.amount,
                senderKey: this.privateKey,
                network,
                memo: details.memo || '',
                anchorMode: transactions_1.AnchorMode.Any,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction (signed but not broadcast)
            const transaction = await (0, transactions_1.makeSTXTokenTransfer)(txOptions);
            // Return the signed transaction hex
            const serialized = transaction.serialize();
            return {
                signedTransaction: Buffer.from(serialized).toString('hex'),
                success: true,
                senderAddress,
            };
        }
        catch (error) {
            return {
                signedTransaction: '',
                success: false,
                error: error instanceof Error ? error.message : 'Transaction signing failed',
            };
        }
    }
    /**
     * Sign sBTC token transfer (without broadcasting)
     */
    async signSBTCTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Get sender address from private key
            const senderAddress = (0, transactions_1.getAddressFromPrivateKey)(details.senderKey, network instanceof network_1.StacksMainnet ? transactions_1.TransactionVersion.Mainnet : transactions_1.TransactionVersion.Testnet);
            // Validate token contract
            if (!details.tokenContract) {
                throw new Error('Token contract required for sBTC transfers');
            }
            const { address: contractAddress, name: contractName } = details.tokenContract;
            // Build function arguments for SIP-010 transfer
            const functionArgs = [
                (0, transactions_1.uintCV)(details.amount.toString()),
                (0, transactions_1.principalCV)(senderAddress),
                (0, transactions_1.principalCV)(details.recipient),
                details.memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(details.memo)) : (0, transactions_1.noneCV)(),
            ];
            // Build transaction options
            const txOptions = {
                contractAddress,
                contractName,
                functionName: 'transfer',
                functionArgs,
                senderKey: this.privateKey,
                network,
                anchorMode: transactions_1.AnchorMode.Any,
                postConditionMode: transactions_1.PostConditionMode.Allow,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction (signed but not broadcast)
            const transaction = await (0, transactions_1.makeContractCall)(txOptions);
            // Return the signed transaction hex
            const serialized = transaction.serialize();
            return {
                signedTransaction: Buffer.from(serialized).toString('hex'),
                success: true,
                senderAddress,
            };
        }
        catch (error) {
            return {
                signedTransaction: '',
                success: false,
                error: error instanceof Error ? error.message : 'sBTC signing failed',
            };
        }
    }
    /**
     * Send STX token transfer
     */
    async sendSTXTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Build transaction options
            const txOptions = {
                recipient: details.recipient,
                amount: details.amount,
                senderKey: this.privateKey,
                network,
                memo: details.memo || '',
                anchorMode: transactions_1.AnchorMode.Any,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction
            const transaction = await (0, transactions_1.makeSTXTokenTransfer)(txOptions);
            // Broadcast transaction
            const broadcastResponse = await (0, transactions_1.broadcastTransaction)(transaction, network);
            // Check for errors in broadcast response
            const txRaw = Buffer.from(transaction.serialize()).toString('hex');
            if ('error' in broadcastResponse) {
                return {
                    txId: '',
                    txRaw,
                    success: false,
                    error: broadcastResponse.error,
                };
            }
            return {
                txId: broadcastResponse.txid,
                txRaw,
                success: true,
            };
        }
        catch (error) {
            return {
                txId: '',
                txRaw: '',
                success: false,
                error: error instanceof Error ? error.message : 'Transaction failed',
            };
        }
    }
    /**
     * Send sBTC token transfer (SIP-010 fungible token)
     */
    async sendSBTCTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Get sender address from private key
            const senderAddress = (0, transactions_1.getAddressFromPrivateKey)(details.senderKey, network instanceof network_1.StacksMainnet ? transactions_1.TransactionVersion.Mainnet : transactions_1.TransactionVersion.Testnet);
            // Validate token contract
            if (!details.tokenContract) {
                throw new Error('Token contract required for sBTC transfers');
            }
            const { address: contractAddress, name: contractName } = details.tokenContract;
            // Build function arguments for SIP-010 transfer
            // transfer function signature: (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34)))
            const functionArgs = [
                (0, transactions_1.uintCV)(details.amount.toString()),
                (0, transactions_1.principalCV)(senderAddress),
                (0, transactions_1.principalCV)(details.recipient),
                details.memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(details.memo)) : (0, transactions_1.noneCV)(),
            ];
            // Build transaction options
            const txOptions = {
                contractAddress,
                contractName,
                functionName: 'transfer',
                functionArgs,
                senderKey: this.privateKey,
                network,
                anchorMode: transactions_1.AnchorMode.Any,
                postConditionMode: transactions_1.PostConditionMode.Allow,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction
            const transaction = await (0, transactions_1.makeContractCall)(txOptions);
            // Broadcast transaction
            const broadcastResponse = await (0, transactions_1.broadcastTransaction)(transaction, network);
            // Check for errors in broadcast response
            const txRaw = Buffer.from(transaction.serialize()).toString('hex');
            if ('error' in broadcastResponse) {
                return {
                    txId: '',
                    txRaw,
                    success: false,
                    error: broadcastResponse.error,
                };
            }
            return {
                txId: broadcastResponse.txid,
                txRaw,
                success: true,
            };
        }
        catch (error) {
            return {
                txId: '',
                txRaw: '',
                success: false,
                error: error instanceof Error ? error.message : 'sBTC transfer failed',
            };
        }
    }
    /**
     * Sign USDCx token transfer (without broadcasting)
     * USDCx is Circle's USDC on Stacks via xReserve (SIP-010 fungible token)
     */
    async signUSDCxTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Get sender address from private key
            const senderAddress = (0, transactions_1.getAddressFromPrivateKey)(details.senderKey, network instanceof network_1.StacksMainnet ? transactions_1.TransactionVersion.Mainnet : transactions_1.TransactionVersion.Testnet);
            // Validate token contract
            if (!details.tokenContract) {
                throw new Error('Token contract required for USDCx transfers');
            }
            const { address: contractAddress, name: contractName } = details.tokenContract;
            // Build function arguments for SIP-010 transfer
            const functionArgs = [
                (0, transactions_1.uintCV)(details.amount.toString()),
                (0, transactions_1.principalCV)(senderAddress),
                (0, transactions_1.principalCV)(details.recipient),
                details.memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(details.memo)) : (0, transactions_1.noneCV)(),
            ];
            // Build transaction options
            const txOptions = {
                contractAddress,
                contractName,
                functionName: 'transfer',
                functionArgs,
                senderKey: this.privateKey,
                network,
                anchorMode: transactions_1.AnchorMode.Any,
                postConditionMode: transactions_1.PostConditionMode.Allow,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction (signed but not broadcast)
            const transaction = await (0, transactions_1.makeContractCall)(txOptions);
            // Return the signed transaction hex
            const serialized = transaction.serialize();
            return {
                signedTransaction: Buffer.from(serialized).toString('hex'),
                success: true,
                senderAddress,
            };
        }
        catch (error) {
            return {
                signedTransaction: '',
                success: false,
                error: error instanceof Error ? error.message : 'USDCx signing failed',
            };
        }
    }
    /**
     * Send USDCx token transfer (SIP-010 fungible token)
     * USDCx is Circle's USDC on Stacks via xReserve
     */
    async sendUSDCxTransfer(details) {
        try {
            // Determine network
            const network = typeof details.network === 'string'
                ? this.getNetworkInstance(details.network)
                : details.network;
            // Get sender address from private key
            const senderAddress = (0, transactions_1.getAddressFromPrivateKey)(details.senderKey, network instanceof network_1.StacksMainnet ? transactions_1.TransactionVersion.Mainnet : transactions_1.TransactionVersion.Testnet);
            // Validate token contract
            if (!details.tokenContract) {
                throw new Error('Token contract required for USDCx transfers');
            }
            const { address: contractAddress, name: contractName } = details.tokenContract;
            // Build function arguments for SIP-010 transfer
            // transfer function signature: (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34)))
            const functionArgs = [
                (0, transactions_1.uintCV)(details.amount.toString()),
                (0, transactions_1.principalCV)(senderAddress),
                (0, transactions_1.principalCV)(details.recipient),
                details.memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(details.memo)) : (0, transactions_1.noneCV)(),
            ];
            // Build transaction options
            const txOptions = {
                contractAddress,
                contractName,
                functionName: 'transfer',
                functionArgs,
                senderKey: this.privateKey,
                network,
                anchorMode: transactions_1.AnchorMode.Any,
                postConditionMode: transactions_1.PostConditionMode.Allow,
                ...(details.nonce !== undefined && { nonce: details.nonce }),
                ...(details.fee !== undefined && { fee: details.fee }),
            };
            // Create transaction
            const transaction = await (0, transactions_1.makeContractCall)(txOptions);
            // Broadcast transaction
            const broadcastResponse = await (0, transactions_1.broadcastTransaction)(transaction, network);
            // Check for errors in broadcast response
            const txRaw = Buffer.from(transaction.serialize()).toString('hex');
            if ('error' in broadcastResponse) {
                return {
                    txId: '',
                    txRaw,
                    success: false,
                    error: broadcastResponse.error,
                };
            }
            return {
                txId: broadcastResponse.txid,
                txRaw,
                success: true,
            };
        }
        catch (error) {
            return {
                txId: '',
                txRaw: '',
                success: false,
                error: error instanceof Error ? error.message : 'USDCx transfer failed',
            };
        }
    }
    /**
     * Make an API request with automatic x402 payment handling
     * Uses the x402 facilitator pattern: client signs, server settles
     */
    async requestWithPayment(url, options = {}) {
        const { method = 'GET', data, headers = {}, maxRetries = 1 } = options;
        let attempt = 0;
        let lastSignedPayment;
        let lastPaymentRequest;
        while (attempt <= maxRetries) {
            try {
                const requestHeaders = { ...headers };
                // Include signed payment if we have one
                if (lastSignedPayment && lastPaymentRequest) {
                    requestHeaders['X-PAYMENT'] = lastSignedPayment;
                    // Also include payment metadata for the server
                    requestHeaders['X-PAYMENT-TOKEN-TYPE'] = lastPaymentRequest.tokenType || 'STX';
                }
                const response = await this.httpClient.request({
                    url,
                    method,
                    data,
                    headers: requestHeaders,
                });
                return response.data;
            }
            catch (error) {
                // Check if it's a 402 Payment Required response
                if (error.response && error.response.status === 402) {
                    const paymentRequest = error.response.data;
                    // Validate payment request
                    if (!this.isValidPaymentRequest(paymentRequest)) {
                        throw new Error('Invalid x402 payment request from server');
                    }
                    // Check expiration
                    const expiresAt = new Date(paymentRequest.expiresAt);
                    if (expiresAt < new Date()) {
                        throw new Error('Payment request has expired');
                    }
                    // Sign payment (don't broadcast - server will do that via facilitator)
                    const signResult = await this.signPayment(paymentRequest);
                    if (!signResult.success) {
                        throw new Error(`Payment signing failed: ${signResult.error}`);
                    }
                    lastSignedPayment = signResult.signedTransaction;
                    lastPaymentRequest = paymentRequest;
                    attempt++;
                    // No need to wait - server will broadcast and wait for confirmation
                    continue;
                }
                // Re-throw if not a 402 error
                throw error;
            }
        }
        throw new Error('Max retries exceeded for payment request');
    }
    /**
     * Validate payment request structure
     */
    isValidPaymentRequest(request) {
        return (typeof request === 'object' &&
            typeof request.maxAmountRequired === 'string' &&
            typeof request.resource === 'string' &&
            typeof request.payTo === 'string' &&
            typeof request.network === 'string' &&
            typeof request.nonce === 'string' &&
            typeof request.expiresAt === 'string' &&
            (request.network === 'mainnet' || request.network === 'testnet'));
    }
    /**
     * Helper to delay execution
     */
    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /**
     * Get the network being used
     */
    getNetwork() {
        return this.network;
    }
}
exports.X402PaymentClient = X402PaymentClient;
