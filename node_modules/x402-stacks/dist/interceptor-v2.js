"use strict";
/**
 * x402-stacks - Axios Payment Interceptor (Coinbase Compatible)
 * Provides automatic x402 payment handling for axios instances
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPaymentClientV2 = exports.withPaymentInterceptorV2 = exports.privateKeyToAccountV2 = void 0;
exports.privateKeyToAccount = privateKeyToAccount;
exports.decodePaymentResponse = decodePaymentResponse;
exports.decodePaymentRequired = decodePaymentRequired;
exports.encodePaymentPayload = encodePaymentPayload;
exports.wrapAxiosWithPayment = wrapAxiosWithPayment;
exports.createPaymentClient = createPaymentClient;
exports.getPaymentResponseFromHeaders = getPaymentResponseFromHeaders;
const transactions_1 = require("@stacks/transactions");
const network_1 = require("@stacks/network");
const types_v2_1 = require("./types-v2");
const utils_1 = require("./utils");
/**
 * Create a Stacks account from a private key
 * Similar to viem's privateKeyToAccount pattern
 */
function privateKeyToAccount(privateKey, network = 'testnet') {
    const transactionVersion = network === 'mainnet'
        ? transactions_1.TransactionVersion.Mainnet
        : transactions_1.TransactionVersion.Testnet;
    const address = (0, transactions_1.getAddressFromPrivateKey)(privateKey, transactionVersion);
    return {
        address,
        privateKey,
        network,
    };
}
/**
 * Decode the payment-response header from base64 JSON
 */
function decodePaymentResponse(header) {
    if (!header)
        return null;
    try {
        const decoded = Buffer.from(header, 'base64').toString('utf-8');
        return JSON.parse(decoded);
    }
    catch {
        return null;
    }
}
/**
 * Decode the payment-required header from base64 JSON
 */
function decodePaymentRequired(header) {
    if (!header)
        return null;
    try {
        const decoded = Buffer.from(header, 'base64').toString('utf-8');
        return JSON.parse(decoded);
    }
    catch {
        return null;
    }
}
/**
 * Encode a payment payload to base64 JSON
 */
function encodePaymentPayload(payload) {
    return Buffer.from(JSON.stringify(payload)).toString('base64');
}
/**
 * Get Stacks network instance from CAIP-2 network identifier
 */
function getNetworkInstanceFromCAIP2(caip2) {
    const network = (0, utils_1.networkFromCAIP2)(caip2);
    return network === 'mainnet' ? new network_1.StacksMainnet() : new network_1.StacksTestnet();
}
/**
 * Get token contract from known assets or network defaults
 */
function getTokenContractForAsset(asset, network) {
    const { tokenType, tokenContract } = (0, utils_1.assetFromV2)(asset);
    if (tokenContract) {
        return tokenContract;
    }
    // Return default contracts for known tokens
    if (tokenType === 'sBTC') {
        return network === 'mainnet'
            ? { address: 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4', name: 'sbtc-token' }
            : { address: 'ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT', name: 'sbtc-token' };
    }
    if (tokenType === 'USDCx') {
        return network === 'mainnet'
            ? { address: 'SP120SBRBQJ00MCWS7TM5R8WJNTTKD5K0HFRC2CNE', name: 'usdcx' }
            : { address: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM', name: 'usdcx' };
    }
    return undefined;
}
/**
 * Sign a payment transaction based on x402 v2 payment requirements
 * Returns the signed transaction hex (does not broadcast)
 */
async function signPaymentV2(paymentRequirements, account) {
    const amount = BigInt(paymentRequirements.amount);
    const { tokenType } = (0, utils_1.assetFromV2)(paymentRequirements.asset);
    const network = getNetworkInstanceFromCAIP2(paymentRequirements.network);
    const v1Network = (0, utils_1.networkFromCAIP2)(paymentRequirements.network);
    // Generate a short memo (max 34 bytes for Stacks)
    const memo = `x402:${Date.now().toString(36)}`.substring(0, 34);
    if (tokenType === 'sBTC' || tokenType === 'USDCx') {
        // SIP-010 token transfer
        const tokenContract = getTokenContractForAsset(paymentRequirements.asset, v1Network);
        if (!tokenContract) {
            throw new Error(`Token contract required for ${tokenType} payments`);
        }
        const functionArgs = [
            (0, transactions_1.uintCV)(amount.toString()),
            (0, transactions_1.principalCV)(account.address),
            (0, transactions_1.principalCV)(paymentRequirements.payTo),
            memo ? (0, transactions_1.someCV)((0, transactions_1.bufferCVFromString)(memo)) : (0, transactions_1.noneCV)(),
        ];
        const transaction = await (0, transactions_1.makeContractCall)({
            contractAddress: tokenContract.address,
            contractName: tokenContract.name,
            functionName: 'transfer',
            functionArgs,
            senderKey: account.privateKey,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
            postConditionMode: transactions_1.PostConditionMode.Allow,
        });
        const serialized = transaction.serialize();
        return Buffer.from(serialized).toString('hex');
    }
    else {
        // STX transfer
        const transaction = await (0, transactions_1.makeSTXTokenTransfer)({
            recipient: paymentRequirements.payTo,
            amount,
            senderKey: account.privateKey,
            network,
            memo,
            anchorMode: transactions_1.AnchorMode.Any,
        });
        const serialized = transaction.serialize();
        return Buffer.from(serialized).toString('hex');
    }
}
/**
 * Validate that a response body is a valid x402 v2 payment request
 */
function isValidPaymentRequestV2(data) {
    if (!data || typeof data !== 'object')
        return false;
    const request = data;
    return (request.x402Version === 2 &&
        typeof request.resource === 'object' &&
        Array.isArray(request.accepts) &&
        request.accepts.length > 0);
}
/**
 * Select the best payment option from available accepts
 * Currently selects the first Stacks-compatible option
 */
function selectPaymentOption(accepts, account) {
    // Find a compatible Stacks payment option
    const compatibleOption = accepts.find((opt) => {
        // Check if network is Stacks
        if (!opt.network.startsWith('stacks:')) {
            return false;
        }
        // Check if network matches account
        const v1Network = (0, utils_1.networkFromCAIP2)(opt.network);
        return v1Network === account.network;
    });
    return compatibleOption || null;
}
// Track which requests have already had payment attempted
const paymentAttempted = new WeakSet();
/**
 * Wrap an axios instance with automatic x402 payment handling
 * Compatible with Coinbase x402 protocol
 *
 * @example
 * ```typescript
 * import axios from 'axios';
 * import { wrapAxiosWithPayment, privateKeyToAccount } from 'x402-stacks';
 *
 * const account = privateKeyToAccount(process.env.PRIVATE_KEY!, 'testnet');
 *
 * const api = wrapAxiosWithPayment(
 *   axios.create({ baseURL: 'https://api.example.com' }),
 *   account
 * );
 *
 * // Use normally - 402 handling is automatic
 * const response = await api.get('/premium-data');
 * console.log(response.data);
 * ```
 */
function wrapAxiosWithPayment(axiosInstance, account) {
    // Response interceptor to handle 402 Payment Required
    axiosInstance.interceptors.response.use(
    // Pass through successful responses
    (response) => response, 
    // Handle errors (including 402)
    async (error) => {
        const originalRequest = error.config;
        // Check if this is a 402 response
        if (error.response?.status !== 402) {
            return Promise.reject(error);
        }
        // Prevent infinite retry loops - only attempt payment once per request
        if (paymentAttempted.has(originalRequest)) {
            return Promise.reject(new Error('Payment already attempted for this request'));
        }
        // Mark this request as having payment attempted
        paymentAttempted.add(originalRequest);
        // Try to get payment requirements from header first, then body
        let paymentRequired = null;
        // Check header
        const headerValue = error.response.headers[types_v2_1.X402_HEADERS.PAYMENT_REQUIRED];
        if (headerValue) {
            paymentRequired = decodePaymentRequired(headerValue);
        }
        // Fall back to body
        if (!paymentRequired && isValidPaymentRequestV2(error.response.data)) {
            paymentRequired = error.response.data;
        }
        if (!paymentRequired) {
            return Promise.reject(new Error('Invalid x402 v2 payment request from server'));
        }
        // Select a compatible payment option
        const selectedOption = selectPaymentOption(paymentRequired.accepts, account);
        if (!selectedOption) {
            return Promise.reject(new Error(`No compatible payment option found. Available networks: ${paymentRequired.accepts.map((a) => a.network).join(', ')}`));
        }
        try {
            // Sign the payment (don't broadcast - server will do that via facilitator)
            const signedTransaction = await signPaymentV2(selectedOption, account);
            // Create V2 payment payload
            const paymentPayload = {
                x402Version: 2,
                resource: paymentRequired.resource,
                accepted: selectedOption,
                payload: {
                    transaction: signedTransaction,
                },
            };
            // Encode payload as base64 for header
            const encodedPayload = encodePaymentPayload(paymentPayload);
            // Retry the request with the payment
            originalRequest.headers = originalRequest.headers || {};
            originalRequest.headers[types_v2_1.X402_HEADERS.PAYMENT_SIGNATURE] = encodedPayload;
            // Make the retry request
            return axiosInstance.request(originalRequest);
        }
        catch (paymentError) {
            return Promise.reject(new Error(`Payment signing failed: ${paymentError instanceof Error ? paymentError.message : 'Unknown error'}`));
        }
    });
    return axiosInstance;
}
/**
 * Create a pre-configured axios instance with payment handling
 * Convenience function that combines axios.create() and wrapAxiosWithPayment()
 *
 * @example
 * ```typescript
 * import { createPaymentClient, privateKeyToAccount } from 'x402-stacks';
 *
 * const account = privateKeyToAccount(process.env.PRIVATE_KEY!, 'testnet');
 * const api = createPaymentClient(account, { baseURL: 'https://api.example.com' });
 *
 * const response = await api.get('/premium-data');
 * ```
 */
function createPaymentClient(account, config) {
    // Dynamic import to avoid requiring axios at module load time
    const axios = require('axios');
    const instance = axios.create(config);
    return wrapAxiosWithPayment(instance, account);
}
// ===== Backward Compatibility Aliases =====
/** @deprecated Use privateKeyToAccount instead */
exports.privateKeyToAccountV2 = privateKeyToAccount;
/** @deprecated Use wrapAxiosWithPayment instead */
exports.withPaymentInterceptorV2 = wrapAxiosWithPayment;
/** @deprecated Use createPaymentClient instead */
exports.createPaymentClientV2 = createPaymentClient;
/**
 * Extract payment response from successful response headers
 */
function getPaymentResponseFromHeaders(response) {
    const header = response.headers[types_v2_1.X402_HEADERS.PAYMENT_RESPONSE];
    return decodePaymentResponse(header);
}
